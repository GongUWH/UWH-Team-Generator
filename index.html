<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#3498db">
    <title>Team Generator & Draw</title>
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
            -webkit-overflow-scrolling: touch;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(45deg, #2c3e50, #3498db);
            color: white;
            padding: 20px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 0.9rem;
        }
        
        .section {
            padding: 20px;
            border-bottom: 1px solid #eee;
        }
        
        .section:last-child {
            border-bottom: none;
        }
        
        .section-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
            display: flex;
            align-items: center;
        }
        
        .section-title::before {
            content: '';
            width: 4px;
            height: 20px;
            background: #3498db;
            margin-right: 10px;
            border-radius: 2px;
        }
        
        .team-count-selector {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #3498db;
        }
        
        .team-count-selector h3 {
            font-size: 1rem;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .radio-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            transition: all 0.2s;
            background: white;
            min-width: 150px;
        }
        
        .radio-option:hover {
            border-color: #3498db;
        }
        
        .radio-option.selected {
            border-color: #3498db;
            background: #e8f0ff;
        }
        
        .radio-option input[type="radio"] {
            margin: 0;
        }
        
        .radio-option label {
            cursor: pointer;
            font-weight: 500;
        }
        
        .grade-inputs {
            display: grid;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .grade-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        
        .grade-group.grade-a { border-left-color: #27ae60; background: #e8f5e8; }
        .grade-group.grade-b { border-left-color: #3498db; background: #e8f0ff; }
        .grade-group.grade-c { border-left-color: #f39c12; background: #fff0e8; }
        
        .grade-group h3 {
            font-size: 1rem;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .grade-group textarea {
            width: 100%;
            min-height: 80px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: inherit;
            font-size: 16px;
            resize: vertical;
            transition: border-color 0.2s;
        }
        
        .grade-group textarea:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        .grade-group small {
            color: #666;
            font-size: 0.8rem;
            margin-top: 8px;
            display: block;
        }
        
        .quick-fill {
            margin-top: 10px;
        }
        
        .quick-fill button {
            background: rgba(52, 152, 219, 0.1);
            border: 1px solid #3498db;
            color: #3498db;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            margin-right: 8px;
            margin-bottom: 5px;
            transition: all 0.2s;
        }
        
        .quick-fill button:hover, .quick-fill button:active {
            background: #3498db;
            color: white;
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            flex: 1;
            min-width: 120px;
            padding: 14px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            touch-action: manipulation;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .btn:active {
            transform: scale(0.98);
        }
        
        .btn-primary {
            background: #3498db;
            color: white;
        }
        
        .btn-primary:hover, .btn-primary:active {
            background: #2980b9;
        }
        
        .btn-success {
            background: #27ae60;
            color: white;
        }
        
        .btn-success:hover, .btn-success:active {
            background: #229954;
        }
        
        .btn-secondary {
            background: #95a5a6;
            color: white;
        }
        
        .btn-secondary:hover, .btn-secondary:active {
            background: #7f8c8d;
        }
        
        .teams-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .team-card {
            background: white;
            border: 2px solid #3498db;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .team-header {
            background: #3498db;
            color: white;
            padding: 12px;
            font-weight: bold;
            text-align: center;
        }
        
        .team-body {
            padding: 15px;
        }
        
        .player {
            padding: 10px;
            margin: 5px 0;
            border-radius: 6px;
            font-weight: 500;
            font-size: 0.9rem;
        }
        
        .player.grade-a { background: #e8f5e8; border-left: 4px solid #27ae60; }
        .player.grade-b { background: #e8f0ff; border-left: 4px solid #3498db; }
        .player.grade-c { background: #fff0e8; border-left: 4px solid #f39c12; }
        
        .team-stats {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
            font-size: 0.8rem;
            color: #666;
            display: flex;
            justify-content: space-between;
        }
        
        .draw-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 0.85rem;
        }
        
        .draw-table th,
        .draw-table td {
            padding: 12px 8px;
            border: 1px solid #ddd;
            text-align: center;
            word-wrap: break-word;
        }
        
        .draw-table th {
            background: #2c3e50;
            color: white;
            font-weight: 600;
            font-size: 0.75rem;
        }
        
        .shallow { background: #e3f2fd; }
        .deep { background: #f3e5f5; }
        
        .alert {
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 0.9rem;
        }
        
        .alert-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        
        .alert-danger {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .stat-card {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid #3498db;
        }
        
        .stat-card h4 {
            margin-bottom: 8px;
            color: #2c3e50;
            font-size: 0.9rem;
        }
        
        .stat-value {
            font-size: 0.8rem;
            color: #666;
        }
        
        .hidden {
            display: none;
        }
        
        .example-players {
            background: rgba(52, 152, 219, 0.05);
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 0.8rem;
            color: #666;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .teams-grid {
                grid-template-columns: 1fr;
            }
            
            .btn-group {
                flex-direction: column;
            }
            
            .btn {
                min-width: 100%;
                padding: 16px 20px;
            }
            
            .draw-table {
                font-size: 0.75rem;
            }
            
            .draw-table th,
            .draw-table td {
                padding: 8px 4px;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .radio-group {
                flex-direction: column;
            }
        }
        
        .table-container {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üèÜ Team Generator</h1>
            <p>Create balanced teams and game draws</p>
        </div>
        
        <div class="section">
            <div class="section-title">‚öôÔ∏è Configuration</div>
            <div class="team-count-selector">
                <h3>Number of Teams</h3>
                <div class="radio-group">
                    <div class="radio-option selected" id="option-2">
                        <input type="radio" id="teams2" name="teamCount" value="2" checked>
                        <label for="teams2">2 Teams (No Draw)</label>
                    </div>
                    <div class="radio-option" id="option-4">
                        <input type="radio" id="teams4" name="teamCount" value="4">
                        <label for="teams4">4 Teams (With Draw)</label>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">üë• Player Input</div>
            <div class="grade-inputs">
                <div class="grade-group grade-a">
                    <h3 id="forwardsTitle">‚ö° 2 Best Forwards</h3>
                    <textarea id="aPlayers" placeholder="Enter your best forward players (one per line)&#10;Example:&#10;Sarah&#10;Mike"></textarea>
                    <small id="forwardsHelp">Top forwards (exactly 1 per team)</small>
                    <div class="quick-fill">
                        <button onclick="fillExample('a')">Fill Example</button>
                        <button onclick="clearField('aPlayers')">Clear</button>
                    </div>
                </div>
                
                <div class="grade-group grade-b">
                    <h3 id="backsTitle">üõ°Ô∏è 2 Best Backs</h3>
                    <textarea id="bPlayers" placeholder="Enter your best back players (one per line)&#10;Example:&#10;Emma&#10;David"></textarea>
                    <small id="backsHelp">Top backs (exactly 1 per team)</small>
                    <div class="quick-fill">
                        <button onclick="fillExample('b')">Fill Example</button>
                        <button onclick="clearField('bPlayers')">Clear</button>
                    </div>
                </div>
                
                <div class="grade-group grade-c">
                    <h3>üë• All Other Players</h3>
                    <textarea id="cPlayers" placeholder="Enter all remaining players (one per line)&#10;Example:&#10;Ashley&#10;Ben&#10;Casey&#10;Drew"></textarea>
                    <small>All remaining players (distributed evenly across teams)</small>
                    <div class="quick-fill">
                        <button onclick="fillExample('c')">Fill Example</button>
                        <button onclick="clearField('cPlayers')">Clear</button>
                    </div>
                </div>
            </div>
            
            <div class="example-players" id="exampleText">
                <strong>üí° Quick Start:</strong> Enter exactly 2 forwards and 2 backs, then add all other players. Tap "Fill Example" to see how it works!
            </div>
            
            <div class="btn-group">
                <button class="btn btn-success" onclick="generateTeams()" id="generateBtn">
                    ‚ö° Generate Teams
                </button>
                <button class="btn btn-secondary" onclick="clearAll()">
                    üóëÔ∏è Clear All
                </button>
            </div>
        </div>
        
        <div class="section" id="teamsSection">
            <div class="section-title">üèÖ Generated Teams</div>
            <div id="teamMessage"></div>
            <div id="teamStats" class="stats-grid hidden"></div>
            <div id="teamsContainer" class="teams-grid"></div>
            
            <div class="btn-group" id="teamButtons" style="display: none;">
                <button class="btn btn-primary" onclick="generateDraw()" id="drawBtn">
                    üìã Generate Draw
                </button>
                <button class="btn btn-secondary" onclick="copyTeams()">
                    üìã Copy Teams
                </button>
                <button class="btn btn-secondary" onclick="clearDraw()">
                    Clear Draw
                </button>
            </div>
        </div>
        
        <div class="section" id="drawSection">
            <div class="section-title">üéÆ Game Draw</div>
            <div id="drawMessage"></div>
            <div id="drawStats" class="stats-grid hidden"></div>
            <div id="drawContainer"></div>
            
            <div class="btn-group" id="drawCopyButtons" style="display: none;">
                <button class="btn btn-secondary" onclick="copyDraw()">
                    üìã Copy Draw
                </button>
            </div>
        </div>
    </div>

    <script>
        let teams = [];
        let lastGeneratedGames = [];
        let currentTeamCount = 2;
        
        // Example player data for different team counts
        const examplePlayers = {
            2: {
                a: ['Sarah (F)', 'Mike (F)'],
                b: ['Emma (B)', 'David (B)'],
                c: ['Ashley', 'Ben', 'Casey', 'Drew', 'Eli', 'Fiona']
            },
            4: {
                a: ['Sarah (F)', 'Mike (F)', 'Alex (F)', 'Jordan (F)'],
                b: ['Emma (B)', 'David (B)', 'Lisa (B)', 'Chris (B)'],
                c: ['Ashley', 'Ben', 'Casey', 'Drew', 'Eli', 'Fiona', 'Grace', 'Henry', 'Ivy', 'Jack', 'Kelly', 'Liam']
            }
        };
        
        // Initialize event listeners when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Set up radio button event listeners
            document.getElementById('option-2').addEventListener('click', () => selectTeamCount(2));
            document.getElementById('option-4').addEventListener('click', () => selectTeamCount(4));
            
            // Set up textarea auto-resize
            const textareas = document.querySelectorAll('textarea');
            textareas.forEach(textarea => {
                textarea.addEventListener('input', function() {
                    autoResize(this);
                });
            });
            
            // Initialize UI for default team count
            updateUIForTeamCount(currentTeamCount);
        });
        
        function selectTeamCount(count) {
            currentTeamCount = count;
            
            // Update radio button selection visually
            document.querySelectorAll('.radio-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.getElementById(`option-${count}`).classList.add('selected');
            
            // Update actual radio button
            document.getElementById(`teams${count}`).checked = true;
            
            // Update UI text based on team count
            updateUIForTeamCount(count);
            
            // Clear existing data
            clearAll(false); // Don't show confirmation
        }
        
        function updateUIForTeamCount(count) {
            const forwardsTitle = document.getElementById('forwardsTitle');
            const backsTitle = document.getElementById('backsTitle');
            const forwardsHelp = document.getElementById('forwardsHelp');
            const backsHelp = document.getElementById('backsHelp');
            const exampleText = document.getElementById('exampleText');
            const drawBtn = document.getElementById('drawBtn');
            
            if (count === 2) {
                forwardsTitle.textContent = '‚ö° 2 Best Forwards';
                backsTitle.textContent = 'üõ°Ô∏è 2 Best Backs';
                forwardsHelp.textContent = 'Top 2 forwards (exactly 1 per team)';
                backsHelp.textContent = 'Top 2 backs (exactly 1 per team)';
                exampleText.innerHTML = '<strong>üí° Quick Start:</strong> Enter exactly 2 forwards and 2 backs, then add all other players. Perfect for simple team splitting!';
                if (drawBtn) drawBtn.style.display = 'none';
            } else {
                forwardsTitle.textContent = '‚ö° 4 Best Forwards';
                backsTitle.textContent = 'üõ°Ô∏è 4 Best Backs';
                forwardsHelp.textContent = 'Top 4 forwards (exactly 1 per team)';
                backsHelp.textContent = 'Top 4 backs (exactly 1 per team)';
                exampleText.innerHTML = '<strong>üí° Quick Start:</strong> Enter exactly 4 forwards and 4 backs, then add all other players. Tap "Fill Example" to see how it works!';
                if (drawBtn) drawBtn.style.display = 'block';
            }
        }
        
        function fillExample(grade) {
            const fieldId = grade + 'Players';
            const field = document.getElementById(fieldId);
            field.value = examplePlayers[currentTeamCount][grade].join('\n');
            autoResize(field);
        }
        
        function clearField(fieldId) {
            const field = document.getElementById(fieldId);
            field.value = '';
            autoResize(field);
        }
        
        function autoResize(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
        }
        
        function collectPlayers() {
            const aText = document.getElementById('aPlayers').value.trim();
            const bText = document.getElementById('bPlayers').value.trim();
            const cText = document.getElementById('cPlayers').value.trim();
            
            return {
                forwards: aText ? aText.split('\n').filter(name => name.trim()).map(name => name.trim()) : [],
                backs: bText ? bText.split('\n').filter(name => name.trim()).map(name => name.trim()) : [],
                others: cText ? cText.split('\n').filter(name => name.trim()).map(name => name.trim()) : []
            };
        }
        
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
        
        function generateTeams() {
            clearMessages();
            
            const btn = document.getElementById('generateBtn');
            const originalText = btn.innerHTML;
            btn.innerHTML = '‚è≥ Generating...';
            btn.disabled = true;
            
            setTimeout(() => {
                const players = collectPlayers();
                
                // Validate required players
                if (players.forwards.length !== currentTeamCount) {
                    showMessage('teamMessage', `‚ö†Ô∏è You must enter exactly ${currentTeamCount} forwards! Currently have: ${players.forwards.length}`, 'error');
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                    return;
                }
                
                if (players.backs.length !== currentTeamCount) {
                    showMessage('teamMessage', `‚ö†Ô∏è You must enter exactly ${currentTeamCount} backs! Currently have: ${players.backs.length}`, 'error');
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                    return;
                }
                
                const totalPlayers = players.forwards.length + players.backs.length + players.others.length;
                const minPlayers = currentTeamCount * 2; // At least forwards + backs
                if (totalPlayers < minPlayers) {
                    showMessage('teamMessage', `‚ö†Ô∏è Need at least ${minPlayers} players total (${currentTeamCount} forwards + ${currentTeamCount} backs + others)! Try using "Fill Example" buttons.`, 'error');
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                    return;
                }
                
                // Shuffle players
                const shuffledForwards = shuffleArray(players.forwards);
                const shuffledBacks = shuffleArray(players.backs);
                const shuffledOthers = shuffleArray(players.others);
                
                // Initialize teams
                teams = [];
                for (let i = 0; i < currentTeamCount; i++) {
                    teams.push({
                        name: `Team ${i + 1}`,
                        players: [],
                        forwards: 0,
                        backs: 0,
                        others: 0
                    });
                }
                
                // Distribute forwards (exactly 1 per team)
                for (let i = 0; i < currentTeamCount; i++) {
                    teams[i].players.push({ name: shuffledForwards[i], position: 'Forward' });
                    teams[i].forwards++;
                }
                
                // Distribute backs (exactly 1 per team)
                for (let i = 0; i < currentTeamCount; i++) {
                    teams[i].players.push({ name: shuffledBacks[i], position: 'Back' });
                    teams[i].backs++;
                }
                
                // Distribute other players evenly
                if (shuffledOthers.length > 0) {
                    const targetOthersPerTeam = Math.floor(shuffledOthers.length / currentTeamCount);
                    const teamsNeedingExtra = shuffledOthers.length % currentTeamCount;
                    
                    let playerIndex = 0;
                    
                    // First phase: fill to target size
                    for (let team = 0; team < currentTeamCount; team++) {
                        for (let j = 0; j < targetOthersPerTeam && playerIndex < shuffledOthers.length; j++) {
                            teams[team].players.push({ name: shuffledOthers[playerIndex], position: 'Player' });
                            teams[team].others++;
                            playerIndex++;
                        }
                    }
                    
                    // Second phase: distribute remaining players
                    let teamIndex = 0;
                    while (playerIndex < shuffledOthers.length && teamIndex < teamsNeedingExtra) {
                        teams[teamIndex].players.push({ name: shuffledOthers[playerIndex], position: 'Player' });
                        teams[teamIndex].others++;
                        playerIndex++;
                        teamIndex++;
                    }
                }
                
                displayTeams();
                document.getElementById('teamButtons').style.display = 'flex';
                
                // Hide draw button for 2 teams
                const drawBtn = document.getElementById('drawBtn');
                if (currentTeamCount === 2) {
                    drawBtn.style.display = 'none';
                } else {
                    drawBtn.style.display = 'block';
                }
                
                const successMessage = currentTeamCount === 2 
                    ? 'üéâ Perfect! 2 balanced teams generated with 1 forward and 1 back each!'
                    : 'üéâ Perfect! Teams generated with 1 forward and 1 back each. Tap "Generate Draw" for the game schedule!';
                    
                showMessage('teamMessage', successMessage, 'success');
                
                btn.innerHTML = originalText;
                btn.disabled = false;
                
                setTimeout(() => {
                    document.getElementById('teamsContainer').scrollIntoView({ behavior: 'smooth' });
                }, 300);
            }, 300);
        }
        
        function displayTeams() {
            const container = document.getElementById('teamsContainer');
            container.innerHTML = '';
            
            teams.forEach((team, index) => {
                const teamDiv = document.createElement('div');
                teamDiv.className = 'team-card';
                
                let playersHtml = '';
                team.players.forEach(player => {
                    const positionClass = player.position === 'Forward' ? 'grade-a' : 
                                         player.position === 'Back' ? 'grade-b' : 'grade-c';
                    const positionLabel = player.position === 'Forward' ? '‚ö°' : 
                                         player.position === 'Back' ? 'üõ°Ô∏è' : 'üë§';
                    playersHtml += `<div class="player ${positionClass}">${positionLabel} ${player.name}</div>`;
                });
                
                teamDiv.innerHTML = `
                    <div class="team-header">${team.name}</div>
                    <div class="team-body">
                        ${playersHtml}
                        <div class="team-stats">
                            <span>Total: ${team.players.length}</span>
                            <span>F:${team.forwards} B:${team.backs} O:${team.others}</span>
                        </div>
                    </div>
                `;
                container.appendChild(teamDiv);
            });
            
            updateTeamStats();
        }
        
        function updateTeamStats() {
            const statsContainer = document.getElementById('teamStats');
            const teamSizes = teams.map(team => team.players.length);
            const minSize = Math.min(...teamSizes);
            const maxSize = Math.max(...teamSizes);
            const isBalanced = maxSize - minSize <= 1;
            
            statsContainer.innerHTML = `
                <div class="stat-card">
                    <h4>Team Balance</h4>
                    <div class="stat-value">
                        Min: ${minSize}, Max: ${maxSize}<br>
                        ${isBalanced ? '‚úÖ Perfectly Balanced' : '‚ö†Ô∏è Needs Adjustment'}
                    </div>
                </div>
                <div class="stat-card">
                    <h4>Position Distribution</h4>
                    <div class="stat-value">
                        Forwards: ${teams.reduce((sum, team) => sum + team.forwards, 0)}<br>
                        Backs: ${teams.reduce((sum, team) => sum + team.backs, 0)}<br>
                        Others: ${teams.reduce((sum, team) => sum + team.others, 0)}
                    </div>
                </div>
                <div class="stat-card">
                    <h4>Position Balance</h4>
                    <div class="stat-value">
                        Each team has:<br>
                        ‚ö° 1 Forward<br>
                        üõ°Ô∏è 1 Back<br>
                        ${teams[0].others > 0 ? `üë§ ${Math.min(...teams.map(t => t.others))}-${Math.max(...teams.map(t => t.others))} Others` : 'üë§ 0 Others'}
                    </div>
                </div>
            `;
            
            statsContainer.classList.remove('hidden');
        }
        
        function generateDraw() {
            if (teams.length !== 4) {
                showMessage('drawMessage', '‚ö†Ô∏è Please generate 4 teams first!', 'error');
                return;
            }
            
            // Generate draw with priority: 1) No repeat matchups, 2) Deep end preference
            const validDraw = generateOptimalDraw();
            
            if (!validDraw.valid) {
                showMessage('drawMessage', '‚ö†Ô∏è Could not generate a valid draw. This should not happen with 4 teams.', 'error');
                return;
            }
            
            lastGeneratedGames = validDraw.games;
            displayDraw(validDraw.games, validDraw.locationCount);
            document.getElementById('drawCopyButtons').style.display = 'flex';
            
            const specialMessage = validDraw.hasDeepEndStrategy ? 
                ' One team plays deep end for all games to ensure no repeat matchups!' : '';
            
            showMessage('drawMessage', 'üéâ Perfect! Tournament draw generated. No team plays another more than once!' + specialMessage, 'success');
            
            setTimeout(() => {
                document.getElementById('drawContainer').scrollIntoView({ behavior: 'smooth' });
            }, 300);
        }
        
        function generateOptimalDraw() {
            // For 4 teams, there are exactly 6 possible matchups: (0,1), (0,2), (0,3), (1,2), (1,3), (2,3)
            // With 3 games, we need to select 6 matchups total (2 per game)
            // This means we can have each pair play exactly once!
            
            const allMatchups = [
                [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]
            ];
            
            // Strategy 1: Try to distribute locations evenly
            const strategy1 = tryDrawStrategy([
                { shallow: [0, 1], deep: [2, 3] }, // matchups: (0,1), (2,3)
                { shallow: [0, 2], deep: [1, 3] }, // matchups: (0,2), (1,3)  
                { shallow: [0, 3], deep: [1, 2] }  // matchups: (0,3), (1,2)
            ]);
            
            if (strategy1.valid && strategy1.balanced) {
                return strategy1;
            }
            
            // Strategy 2: Favor one team in deep end for all games
            const deepEndStrategies = [
                // Team 0 always in deep
                [
                    { shallow: [1, 2], deep: [0, 3] }, // matchups: (1,2), (0,3)
                    { shallow: [1, 3], deep: [0, 2] }, // matchups: (1,3), (0,2)
                    { shallow: [2, 3], deep: [0, 1] }  // matchups: (2,3), (0,1)
                ],
                // Team 1 always in deep
                [
                    { shallow: [0, 2], deep: [1, 3] }, // matchups: (0,2), (1,3)
                    { shallow: [0, 3], deep: [1, 2] }, // matchups: (0,3), (1,2)
                    { shallow: [2, 3], deep: [1, 0] }  // matchups: (2,3), (1,0)
                ],
                // Team 2 always in deep
                [
                    { shallow: [0, 1], deep: [2, 3] }, // matchups: (0,1), (2,3)
                    { shallow: [0, 3], deep: [2, 1] }, // matchups: (0,3), (2,1)
                    { shallow: [1, 3], deep: [2, 0] }  // matchups: (1,3), (2,0)
                ],
                // Team 3 always in deep
                [
                    { shallow: [0, 1], deep: [3, 2] }, // matchups: (0,1), (3,2)
                    { shallow: [0, 2], deep: [3, 1] }, // matchups: (0,2), (3,1)
                    { shallow: [1, 2], deep: [3, 0] }  // matchups: (1,2), (3,0)
                ]
            ];
            
            // Try each deep end strategy
            for (const strategy of deepEndStrategies) {
                const result = tryDrawStrategy(strategy, true);
                if (result.valid) {
                    result.hasDeepEndStrategy = true;
                    return result;
                }
            }
            
            // Fallback: return strategy1 even if not perfectly balanced
            if (strategy1.valid) {
                return strategy1;
            }
            
            return { valid: false };
        }
        
        function tryDrawStrategy(schedule, isDeepEndStrategy = false) {
            const locationCount = {
                0: { Shallow: 0, Deep: 0 },
                1: { Shallow: 0, Deep: 0 },
                2: { Shallow: 0, Deep: 0 },
                3: { Shallow: 0, Deep: 0 }
            };
            
            const usedMatchups = new Set();
            
            // Check if all matchups are unique
            for (const game of schedule) {
                // Check shallow matchup
                const shallowMatchup = game.shallow.slice().sort().join('-');
                if (usedMatchups.has(shallowMatchup)) {
                    return { valid: false }; // Repeat matchup found
                }
                usedMatchups.add(shallowMatchup);
                
                // Check deep matchup
                const deepMatchup = game.deep.slice().sort().join('-');
                if (usedMatchups.has(deepMatchup)) {
                    return { valid: false }; // Repeat matchup found
                }
                usedMatchups.add(deepMatchup);
                
                // Count locations
                locationCount[game.shallow[0]].Shallow++;
                locationCount[game.shallow[1]].Shallow++;
                locationCount[game.deep[0]].Deep++;
                locationCount[game.deep[1]].Deep++;
            }
            
            // Build games with random color assignment
            const games = schedule.map((game, index) => {
                const shallowBlack = Math.random() < 0.5 ? game.shallow[0] : game.shallow[1];
                const shallowWhite = shallowBlack === game.shallow[0] ? game.shallow[1] : game.shallow[0];
                const deepBlack = Math.random() < 0.5 ? game.deep[0] : game.deep[1];
                const deepWhite = deepBlack === game.deep[0] ? game.deep[1] : game.deep[0];
                
                return {
                    game: index + 1,
                    shallowBlack: teams[shallowBlack].name,
                    shallowWhite: teams[shallowWhite].name,
                    deepBlack: teams[deepBlack].name,
                    deepWhite: teams[deepWhite].name
                };
            });
            
            // Check if locations are reasonably balanced (max 2 games per location per team)
            let balanced = true;
            Object.values(locationCount).forEach(count => {
                if (count.Shallow > 2 || count.Deep > 2) {
                    balanced = false;
                }
            });
            
            return {
                valid: true,
                balanced: balanced,
                games: games,
                locationCount: locationCount,
                hasDeepEndStrategy: isDeepEndStrategy
            };
        }
        
        function displayDraw(games, locationCount) {
            const container = document.getElementById('drawContainer');
            
            let tableHtml = `
                <div class="table-container">
                    <table class="draw-table">
                        <thead>
                            <tr>
                                <th style="width: 15%;">Game</th>
                                <th style="width: 21%;">Shallow Black</th>
                                <th style="width: 21%;">Shallow White</th>
                                <th style="width: 21%;">Deep Black</th>
                                <th style="width: 21%;">Deep White</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            games.forEach(game => {
                tableHtml += `
                    <tr>
                        <td><strong>Game ${game.game}</strong></td>
                        <td class="shallow">${game.shallowBlack}</td>
                        <td class="shallow">${game.shallowWhite}</td>
                        <td class="deep">${game.deepBlack}</td>
                        <td class="deep">${game.deepWhite}</td>
                    </tr>
                `;
            });
            
            tableHtml += `</tbody></table></div>
                <div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px; font-size: 0.8rem; color: #666;">
                    üìç <strong>Quick Reference:</strong> Blue = Shallow Location, Purple = Deep Location
                </div>`;
            
            container.innerHTML = tableHtml;
            updateLocationStats(locationCount);
        }
        
        function updateLocationStats(locationCount) {
            const statsContainer = document.getElementById('drawStats');
            let statsHtml = '';
            
            Object.keys(locationCount).forEach(teamIndex => {
                const shallow = locationCount[teamIndex].Shallow;
                const deep = locationCount[teamIndex].Deep;
                const balanced = shallow <= 2 && deep <= 2;
                
                // Special indicator for deep end strategy
                const deepEndNote = deep === 3 ? ' (Deep End Strategy)' : '';
                
                statsHtml += `
                    <div class="stat-card">
                        <h4>${teams[teamIndex].name}</h4>
                        <div class="stat-value">
                            Shallow: ${shallow} games, Deep: ${deep} games
                            ${balanced ? ' ‚úÖ Balanced' : ' ‚ö†Ô∏è Imbalanced'}${deepEndNote}
                        </div>
                    </div>
                `;
            });
            
            statsContainer.innerHTML = statsHtml;
            statsContainer.classList.remove('hidden');
        }
        
        function copyTeams() {
            if (teams.length === 0) {
                showMessage('teamMessage', '‚ö†Ô∏è No teams to copy! Generate teams first.', 'error');
                return;
            }
            
            let copyText = 'üèÜ TEAM GENERATOR RESULTS\n';
            copyText += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';
            
            teams.forEach(team => {
                copyText += `${team.name.toUpperCase()}\n`;
                copyText += '‚îÄ'.repeat(team.name.length) + '\n';
                
                team.players.forEach(player => {
                    const icon = player.position === 'Forward' ? '‚ö°' : 
                                player.position === 'Back' ? 'üõ°Ô∏è' : 'üë§';
                    copyText += `${icon} ${player.name}\n`;
                });
                
                copyText += `\nTotal: ${team.players.length} | Forwards: ${team.forwards} | Backs: ${team.backs} | Others: ${team.others}\n\n`;
            });
            
            // Add balance info
            const teamSizes = teams.map(team => team.players.length);
            const minSize = Math.min(...teamSizes);
            const maxSize = Math.max(...teamSizes);
            const isBalanced = maxSize - minSize <= 1;
            
            copyText += 'üìä TEAM BALANCE\n';
            copyText += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
            copyText += `Team sizes: ${teamSizes.join(', ')}\n`;
            copyText += `Balance: ${isBalanced ? '‚úÖ Perfectly Balanced' : '‚ö†Ô∏è Needs Adjustment'}\n`;
            copyText += `Each team has exactly 1 forward and 1 back\n\n`;
            copyText += 'Generated by Team Generator App üèÜ';
            
            copyToClipboard(copyText, 'teamMessage', 'Teams');
        }
        
        function copyDraw() {
            if (!lastGeneratedGames || lastGeneratedGames.length === 0) {
                showMessage('drawMessage', '‚ö†Ô∏è No draw to copy! Generate draw first.', 'error');
                return;
            }
            
            let copyText = 'üéÆ TOURNAMENT DRAW\n';
            copyText += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';
            
            lastGeneratedGames.forEach(game => {
                copyText += `GAME ${game.game}\n`;
                copyText += '‚îÄ'.repeat(6) + '\n';
                copyText += `üèä SHALLOW: ${game.shallowBlack} (Black) vs ${game.shallowWhite} (White)\n`;
                copyText += `üèä‚Äç‚ôÇÔ∏è DEEP: ${game.deepBlack} (Black) vs ${game.deepWhite} (White)\n\n`;
            });
            
            // Add location balance info
            copyText += 'üìç LOCATION BALANCE\n';
            copyText += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
            const locationStats = document.getElementById('drawStats');
            if (locationStats && !locationStats.classList.contains('hidden')) {
                const statCards = locationStats.querySelectorAll('.stat-card');
                statCards.forEach(card => {
                    const teamName = card.querySelector('h4').textContent;
                    const statValue = card.querySelector('.stat-value').textContent.replace(/\s+/g, ' ').trim();
                    copyText += `${teamName}: ${statValue}\n`;
                });
            }
            
            copyText += '\n‚úÖ No teams play each other more than once - GUARANTEED!\n';
            copyText += '‚úÖ Deep end strategy used when needed for unique matchups\n\n';
            copyText += 'Generated by Team Generator App üéÆ';
            
            copyToClipboard(copyText, 'drawMessage', 'Draw');
        }
        
        function copyToClipboard(text, messageElementId, type) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    showMessage(messageElementId, `‚úÖ ${type} copied to clipboard! Ready to share.`, 'success');
                }).catch(() => {
                    fallbackCopyTextToClipboard(text, messageElementId, type);
                });
            } else {
                fallbackCopyTextToClipboard(text, messageElementId, type);
            }
        }
        
        function fallbackCopyTextToClipboard(text, messageElementId, type) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.top = '0';
            textArea.style.left = '0';
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            textArea.style.padding = '0';
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            textArea.style.background = 'transparent';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showMessage(messageElementId, `‚úÖ ${type} copied to clipboard! Ready to share.`, 'success');
                } else {
                    showMessage(messageElementId, `‚ö†Ô∏è Could not copy ${type.toLowerCase()}. Try selecting and copying manually.`, 'error');
                }
            } catch (err) {
                showMessage(messageElementId, `‚ö†Ô∏è Could not copy ${type.toLowerCase()}. Try selecting and copying manually.`, 'error');
            }
            
            document.body.removeChild(textArea);
        }
        
        function clearAll(showConfirm = true) {
            if (showConfirm && !confirm('üóëÔ∏è This will clear all player names and results. Are you sure?')) {
                return;
            }
            
            teams = [];
            lastGeneratedGames = [];
            document.getElementById('aPlayers').value = '';
            document.getElementById('bPlayers').value = '';
            document.getElementById('cPlayers').value = '';
            document.getElementById('teamsContainer').innerHTML = '';
            document.getElementById('drawContainer').innerHTML = '';
            document.getElementById('teamStats').classList.add('hidden');
            document.getElementById('drawStats').classList.add('hidden');
            document.getElementById('teamButtons').style.display = 'none';
            document.getElementById('drawCopyButtons').style.display = 'none';
            clearMessages();
            
            if (showConfirm) {
                showMessage('teamMessage', '‚ú® Ready for new players! Enter names above and tap "Generate Teams".', 'success');
            }
        }
        
        function clearDraw() {
            if (confirm('üóëÔ∏è This will clear the current draw. Are you sure?')) {
                lastGeneratedGames = [];
                document.getElementById('drawContainer').innerHTML = '';
                document.getElementById('drawStats').classList.add('hidden');
                document.getElementById('drawCopyButtons').style.display = 'none';
                clearDrawMessages();
            }
        }
        
        function clearMessages() {
            document.getElementById('teamMessage').innerHTML = '';
            document.getElementById('drawMessage').innerHTML = '';
        }
        
        function clearDrawMessages() {
            document.getElementById('drawMessage').innerHTML = '';
        }
        
        function showMessage(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="alert alert-${type === 'error' ? 'danger' : 'success'}">${message}</div>`;
        }
    </script>
</body>
</html>
